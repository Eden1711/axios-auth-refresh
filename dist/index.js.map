{"version":3,"sources":["../src/index.ts"],"sourcesContent":["// src/index.ts\nimport {\n  AxiosInstance,\n  AxiosRequestConfig,\n  AxiosError,\n  AxiosResponse,\n  InternalAxiosRequestConfig,\n} from \"axios\";\n\n// 1. Định nghĩa các kiểu dữ liệu (Types)\nexport interface AuthTokens {\n  accessToken: string;\n  refreshToken?: string;\n}\n\nexport interface AuthInterceptorConfig {\n  /** Hàm gọi API refresh token. Trả về Promise chứa token mới. */\n  requestRefresh: (refreshToken: string) => Promise<AuthTokens>;\n\n  /** Hàm lấy refresh token từ storage (localStorage, cookie...). */\n  getRefreshToken: () => string | null | undefined;\n\n  /** Callback chạy khi refresh thành công (để bạn lưu token mới). */\n  onSuccess: (tokens: AuthTokens) => void;\n\n  /** Callback chạy khi refresh thất bại (để bạn logout, clear storage). */\n  onFailure: (error: any) => void;\n\n  /** (Tùy chọn) Tự custom cách gắn token vào header. Mặc định là 'Authorization: Bearer ...' */\n  attachTokenToRequest?: (\n    request: InternalAxiosRequestConfig,\n    token: string\n  ) => void;\n}\n\n// Hàng đợi lưu các request bị fail để retry sau\ninterface FailedRequest {\n  resolve: (value: any) => void;\n  reject: (reason?: any) => void;\n}\n\n// 2. Logic chính\nexport const applyAuthTokenInterceptor = (\n  axiosInstance: AxiosInstance,\n  config: AuthInterceptorConfig\n) => {\n  let isRefreshing = false;\n  let failedQueue: FailedRequest[] = [];\n\n  // Hàm xử lý hàng đợi: Duyệt qua các request đang chờ và quyết định retry hay reject\n  const processQueue = (error: any, token: string | null = null) => {\n    failedQueue.forEach((prom) => {\n      if (error) {\n        prom.reject(error);\n      } else {\n        prom.resolve(token);\n      }\n    });\n    failedQueue = [];\n  };\n\n  // Hàm mặc định để gắn token nếu user không truyền attachTokenToRequest\n  const defaultAttachToken = (\n    request: InternalAxiosRequestConfig,\n    token: string\n  ) => {\n    request.headers.set(\"Authorization\", `Bearer ${token}`);\n  };\n\n  // INTERCEPTOR LOGIC\n  axiosInstance.interceptors.response.use(\n    (response: AxiosResponse) => response,\n    async (error: AxiosError) => {\n      const originalRequest = error.config as InternalAxiosRequestConfig & {\n        _retry?: boolean;\n      };\n\n      // Nếu không phải lỗi 401 hoặc request này đã từng retry rồi -> Bỏ qua\n      if (\n        error.response?.status !== 401 ||\n        !originalRequest ||\n        originalRequest._retry\n      ) {\n        return Promise.reject(error);\n      }\n\n      // CASE 1: Đang có một request khác thực hiện refresh token\n      if (isRefreshing) {\n        return new Promise(function (resolve, reject) {\n          failedQueue.push({\n            resolve: (token: string) => {\n              // Khi có token mới, gắn lại vào request cũ và gọi lại\n              const attachToken =\n                config.attachTokenToRequest || defaultAttachToken;\n              attachToken(originalRequest, token);\n              resolve(axiosInstance(originalRequest));\n            },\n            reject: (err) => {\n              reject(err);\n            },\n          });\n        });\n      }\n\n      // CASE 2: Chưa ai refresh, bắt đầu quy trình refresh\n      originalRequest._retry = true;\n      isRefreshing = true;\n\n      try {\n        const refreshToken = config.getRefreshToken();\n\n        if (!refreshToken) {\n          throw new Error(\"No refresh token available\");\n        }\n\n        // Gọi hàm refresh của user\n        const newTokens = await config.requestRefresh(refreshToken);\n\n        // Refresh thành công\n        config.onSuccess(newTokens);\n\n        // Cập nhật token cho request hiện tại (người khởi xướng)\n        const attachToken = config.attachTokenToRequest || defaultAttachToken;\n        attachToken(originalRequest, newTokens.accessToken);\n\n        // Chạy lại hàng đợi (những request bị kẹt lúc đang refresh)\n        processQueue(null, newTokens.accessToken);\n\n        // Gọi lại request ban đầu\n        return axiosInstance(originalRequest);\n      } catch (err) {\n        // Refresh thất bại (Token hết hạn hẳn hoặc API lỗi)\n        processQueue(err, null);\n        config.onFailure(err);\n        return Promise.reject(err);\n      } finally {\n        isRefreshing = false;\n      }\n    }\n  );\n};\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,+BAAAE,IAAA,eAAAC,EAAAH,GA0CO,IAAME,EAA4B,CACvCE,EACAC,IACG,CACH,IAAIC,EAAe,GACfC,EAA+B,CAAC,EAG9BC,EAAe,CAACC,EAAYC,EAAuB,OAAS,CAChEH,EAAY,QAASI,GAAS,CACxBF,EACFE,EAAK,OAAOF,CAAK,EAEjBE,EAAK,QAAQD,CAAK,CAEtB,CAAC,EACDH,EAAc,CAAC,CACjB,EAGMK,EAAqB,CACzBC,EACAH,IACG,CACHG,EAAQ,QAAQ,IAAI,gBAAiB,UAAUH,CAAK,EAAE,CACxD,EAGAN,EAAc,aAAa,SAAS,IACjCU,GAA4BA,EAC7B,MAAOL,GAAsB,CAxEjC,IAAAM,EAyEM,IAAMC,EAAkBP,EAAM,OAK9B,KACEM,EAAAN,EAAM,WAAN,YAAAM,EAAgB,UAAW,KAC3B,CAACC,GACDA,EAAgB,OAEhB,OAAO,QAAQ,OAAOP,CAAK,EAI7B,GAAIH,EACF,OAAO,IAAI,QAAQ,SAAUW,EAASC,EAAQ,CAC5CX,EAAY,KAAK,CACf,QAAUG,GAAkB,EAGxBL,EAAO,sBAAwBO,GACrBI,EAAiBN,CAAK,EAClCO,EAAQb,EAAcY,CAAe,CAAC,CACxC,EACA,OAASG,GAAQ,CACfD,EAAOC,CAAG,CACZ,CACF,CAAC,CACH,CAAC,EAIHH,EAAgB,OAAS,GACzBV,EAAe,GAEf,GAAI,CACF,IAAMc,EAAef,EAAO,gBAAgB,EAE5C,GAAI,CAACe,EACH,MAAM,IAAI,MAAM,4BAA4B,EAI9C,IAAMC,EAAY,MAAMhB,EAAO,eAAee,CAAY,EAG1D,OAAAf,EAAO,UAAUgB,CAAS,GAGNhB,EAAO,sBAAwBO,GACvCI,EAAiBK,EAAU,WAAW,EAGlDb,EAAa,KAAMa,EAAU,WAAW,EAGjCjB,EAAcY,CAAe,CACtC,OAASG,EAAK,CAEZ,OAAAX,EAAaW,EAAK,IAAI,EACtBd,EAAO,UAAUc,CAAG,EACb,QAAQ,OAAOA,CAAG,CAC3B,QAAE,CACAb,EAAe,EACjB,CACF,CACF,CACF","names":["index_exports","__export","applyAuthTokenInterceptor","__toCommonJS","axiosInstance","config","isRefreshing","failedQueue","processQueue","error","token","prom","defaultAttachToken","request","response","_a","originalRequest","resolve","reject","err","refreshToken","newTokens"]}